from __future__ import division, print_function

from ._global_imports import *
from ._run import Run

try:
    from getdist.mcsamples import MCSamples
except ImportError:
    _warning('Cannot create a GetDist sample backend.')

try:
    from nestcheck.data_processing import process_multinest_run
    from nestcheck.data_processing import process_polychord_run
except ImportError:
    _warning('Cannot use nestcheck sample backend.')

class NestedBackend(Run):
    """
    Container for nested samples generated by a single run, and backends
    for analysis of the run.

    The other keyword arguments are generic properties passed to the parent
    class, such as the identification (ID) string of the run.

    :param str root:
        The root filename of the sample file collection.

    :param str base_dir:
        The directly containing the sample file collection.

    :param bool use_nestcheck:
        Invoke :mod:`nestcheck` for nested sampling error analysis?

    :param callable transform:
        A function to transform the parameter vector to another space.

    """

    def __init__(self, root, base_dir, use_nestcheck, transform=None,
                 overwrite_transformed=False, **kwargs):
        filerootpath =_os.path.join(base_dir, root)
        _filerootpath = filerootpath

        if transform is not None:
            samples = _np.loadtxt(filerootpath+'.txt')
            ndims = samples.shape[1] - 2
            temp = transform(samples[0,2:], old_API=True)
            ntransform = len(temp) - ndims

            _exists = _os.path.isfile(filerootpath+'_transformed.txt')
            if not _exists or overwrite_transformed:
                transformed = _np.zeros((samples.shape[0],
                                         samples.shape[1] + ntransform))
                transformed[:,:2] = samples[:,:2]
                for i in range(samples.shape[0]):
                    transformed[i,2:] = transform(samples[i,2:], old_API=True)
                _np.savetxt(filerootpath+'_transformed.txt', transformed)

            filerootpath += '_transformed'
            root += '_transformed'

        super(NestedBackend, self).__init__(filepath=filerootpath+'.txt',**kwargs)

        if getdist is not None:
            # getdist backend
            self._gd_bcknd = MCSamples(root=filerootpath,
                             settings=self.kde_settings,
                             sampler='nested',
                             names=self.names,
                             ranges=self.bounds,
                             labels=[self.labels[name] for name in self.names])
            self._gd_bcknd.readChains(getdist.chains.chainFiles(filerootpath))

        self.use_nestcheck = use_nestcheck

        if self.use_nestcheck: # nestcheck backend
            if transform is not None:
                for ext in ['dead-birth.txt', 'phys_live-birth.txt']:
                    _exists = _os.path.isfile(filerootpath + ext)
                    if not _exists or overwrite_transformed:
                        samples = _np.loadtxt(_filerootpath + ext)
                        transformed = _np.zeros((samples.shape[0],
                                                 samples.shape[1] + ntransform))
                        transformed[:,ndims+ntransform:] = samples[:,ndims:]
                        for i in range(samples.shape[0]):
                            transformed[i,:ndims+ntransform] =\
                                                transform(samples[i,:ndims],
                                                          old_API=True)

                        _np.savetxt(filerootpath + ext, transformed)

                # .stats file with same root needed, but do not need to modify
                # the .stats file contents
                if not _os.path.isfile(filerootpath + '.stats'):
                    if _os.path.isfile(_filerootpath + '.stats'):
                        try:
                            from shutil import copyfile as _copyfile
                        except ImportError:
                            pass
                        else:
                            _copyfile(_filerootpath + '.stats',
                                      filerootpath + '.stats')
            try:
                kwargs['implementation']
            except KeyError:
                print('Root %r sampling implementation not specified... '
                      'assuming MultiNest for nestcheck...')
                self._nc_bcknd = process_multinest_run(root,
                                                       base_dir=base_dir)
            else:
                if kwargs['implementation'] == 'multinest':
                    self._nc_bcknd = process_multinest_run(root,
                                                           base_dir=base_dir)
                elif kwargs['implementation'] == 'polychord':
                    self._nc_bcknd = process_polychord_run(root,
                                                           base_dir=base_dir)
                else:
                    raise ValueError('Cannot process with nestcheck.')

    @property
    def getdist_backend(self):
        """ Get the :class:`getdist.mcsamples.MCSamples` instance. """
        return self._gd_bcknd

    @property
    def nestcheck_backend(self):
        """ Get the :mod:`nestcheck` backend for the nested samples. """
        return self._nc_bcknd

    @property
    def margeStats(self):
        """ Return the marginal statistics using :mod:`getdist`. """
        return self._mcsamples.getMargeStats()


###===>>> requires update

try:
    from emcee.backends import HDFBackend
except ImportError:
    if _verbose:
        print('Warning: Cannot import emcee.')

class EnesembleBackend(Run):
    """ Prepare `emcee`_ samples for use with :mod:`getdist`.

    .. _emcee: http://dfm.io/emcee/current/

    .. todo::

        Update to ensure compatibility, although nested sampling is
        recommended and has most features.

    :param backend: A :class:`emcee.backends.HDFBackend` instance.

    :param list names: An ordered list of ``str`` parameter names.
                       The ordering must match the parameter vector 
                       ordering defined in :obj:`backend`.

    :param int burn: If ``None``, defaults to the minumum of zero.

    :param int thin: If ``None``, defaults to the minumum of one.

    """
    def __init__(self, ID, backend, names, bounds, labels, burn, thin,
                 lines, contours, walker_discard=None,
                 settings = {}, truths = None):
        super(EMCbackend, self).__init__(self, ID, names, bounds, labels,
                                         lines, contours, truths)

        self.backend = backend

        self._mcsamples = MCSamples(samples = self._extract_samples(burn, thin, walker_discard),
                                    names = self.names,
                                    ranges = self.bounds,
                                    labels = self.labels,
                                    settings = settings)

    def _extract_samples(self, burn, thin, walker_discard):
        """ Extract samples from a :class:`~emcee.backends.HDFBackend` instance.

        :param int burn: Number of iterations to discard from the start of the
                         sampling process. Can be ``'last'``, in which case
                         only the last ensemble state is used; in this case
                         :obj:`thin` is ignored.

        :param int thin: Number of iterations to thin by to reduce
                         autocorrelation between samples such that they are
                         approximately i.i.d.

        :param walker_discard: A :class:`numpy.ndarray` of walker numbers to
                               discard from the flattened set of samples. This
                               is useful if a subset of walkers get stuck in
                               parameter space due to complex structures and
                               an inefficient proposal distribution for
                               global mapping when such structure exists.
                               If ``None`` no walkers are discarded.

        :return: An ``s x d`` :class:`numpy.ndarray` of samples, where ``n`` is
                 the number of samples and ``d`` is the number of parameters.

        """
        try:
            samples = self.backend.get_chain(discard = int(burn),
                                             thin = int(thin),
                                             flat = False)
        except TypeError:
            if burn is None: burn = 0
            if thin is None: thin = 1

            samples = self.backend.get_chain(discard = burn,
                                             thin = thin,
                                             flat = False)
        if walker_discard is not None:
            try:
                walkers = _np.arange(samples.shape[1])
                walkers = _np.delete(walkers, walker_discard)
                samples = samples[:,walkers,:]
            except IndexError:
                print('Invalid indexing instructions for discarding walkers.')
                raise

        s = list(samples.shape[1:])
        s[0] = _np.prod(samples.shape[:2])

        return samples.reshape(s)

    @property
    def backend(self):
        """ Get the :class:`emcee.backends.HDFBackend` instance. """
        return self._backend

    @backend.setter
    def backend(self, obj):
        """ Set the sample storage backend. """

        try:
            from emcee.backends import HDFBackend
        except ImportError:
            raise ImportError('Check your ``emcee`` installation.')
        else:
            if not isinstance(obj, HDFBackend):
                raise TypeError('Incompatible backend for samples.')
        self._backend = obj

    @property
    def reader(self):
        """ Get the reader. """
        return self._reader

    @reader.setter
    def reader(self, obj):
        """ Set the reader. """
        if isinstance(obj, HDFBackend):
            self._reader = obj
        else:
            raise TypeError('Invalid backend object.')
